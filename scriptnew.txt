# Nintex Forms PDF Export - SharePoint Server (Classic PowerShell)
# Run this script directly on the SharePoint Server

param(
    [Parameter(Mandatory=$true)]
    [string]$WebUrl,
    
    [Parameter(Mandatory=$true)]
    [string]$ListName,
    
    [Parameter(Mandatory=$true)]
    [string]$OutputPath,
    
    [Parameter(Mandatory=$false)]
    [string]$Method = "Chrome", # Options: "Chrome", "wkhtmltopdf"
    
    [Parameter(Mandatory=$false)]
    [string]$ChromePath = "C:\Program Files\Google\Chrome\Application\chrome.exe",
    
    [Parameter(Mandatory=$false)]
    [string]$wkhtmltopdfPath = "C:\Program Files\wkhtmltopdf\bin\wkhtmltopdf.exe",
    
    [Parameter(Mandatory=$false)]
    [int]$BatchSize = 50  # Process items in batches to avoid memory issues
)

# Load SharePoint PowerShell Snap-in
Write-Host "Loading SharePoint PowerShell..." -ForegroundColor Yellow
try {
    Add-PSSnapin Microsoft.SharePoint.PowerShell -ErrorAction Stop
    Write-Host "SharePoint PowerShell loaded successfully" -ForegroundColor Green
}
catch {
    Write-Error "Failed to load SharePoint PowerShell. Ensure you're running on a SharePoint server."
    exit 1
}

# Function to export using Chrome headless
function Export-WithChrome {
    param(
        [string]$Url,
        [string]$OutputFile,
        [string]$ChromePath
    )
    
    $arguments = @(
        "--headless",
        "--disable-gpu",
        "--no-sandbox",
        "--disable-dev-shm-usage",
        "--disable-web-security",
        "--disable-features=VizDisplayCompositor",
        "--virtual-time-budget=15000",
        "--run-all-compositor-stages-before-draw",
        "--print-to-pdf=`"$OutputFile`"",
        "--print-to-pdf-no-header",
        "`"$Url`""
    )
    
    try {
        $process = Start-Process -FilePath $ChromePath -ArgumentList $arguments -Wait -NoNewWindow -PassThru
        
        # Wait a moment for file to be written
        Start-Sleep -Seconds 2
        
        if (Test-Path $OutputFile -and (Get-Item $OutputFile).Length -gt 1KB) {
            return $true
        } else {
            return $false
        }
    }
    catch {
        Write-Warning "Chrome export failed: $($_.Exception.Message)"
        return $false
    }
}

# Function to export using wkhtmltopdf
function Export-WithWkhtmltopdf {
    param(
        [string]$Url,
        [string]$OutputFile,
        [string]$WkhtmltopdfPath
    )
    
    $arguments = @(
        "--page-size", "A4",
        "--margin-top", "0.75in",
        "--margin-right", "0.75in",
        "--margin-bottom", "0.75in", 
        "--margin-left", "0.75in",
        "--encoding", "UTF-8",
        "--no-outline",
        "--enable-local-file-access",
        "--load-error-handling", "ignore",
        "--load-media-error-handling", "ignore",
        "--javascript-delay", "5000",
        "--no-stop-slow-scripts",
        "`"$Url`"",
        "`"$OutputFile`""
    )
    
    try {
        $process = Start-Process -FilePath $WkhtmltopdfPath -ArgumentList $arguments -Wait -NoNewWindow -PassThru
        
        if (Test-Path $OutputFile -and (Get-Item $OutputFile).Length -gt 1KB) {
            return $true
        } else {
            return $false
        }
    }
    catch {
        Write-Warning "wkhtmltopdf export failed: $($_.Exception.Message)"
        return $false
    }
}

# Function to get all list items using SharePoint Object Model
function Get-SharePointListItems {
    param(
        [string]$WebUrl,
        [string]$ListName
    )
    
    Write-Host "Connecting to SharePoint site: $WebUrl" -ForegroundColor Yellow
    
    try {
        # Get the SharePoint site and web
        $site = Get-SPSite $WebUrl
        if (!$site) {
            $site = Get-SPSite | Where-Object { $_.Url -like "*$WebUrl*" -or $_.RootWeb.Url -eq $WebUrl }
        }
        
        if (!$site) {
            throw "Could not find site with URL: $WebUrl"
        }
        
        $web = $site.OpenWeb()
        Write-Host "Connected to web: $($web.Title)" -ForegroundColor Green
        
        # Get the list
        $list = $web.Lists.TryGetList($ListName)
        if (!$list) {
            # Try by display name
            $list = $web.Lists | Where-Object { $_.Title -eq $ListName }
        }
        
        if (!$list) {
            throw "List '$ListName' not found in web '$($web.Title)'"
        }
        
        Write-Host "Found list: $($list.Title) with $($list.ItemCount) items" -ForegroundColor Green
        
        $formData = @()
        $itemCount = 0
        
        # Get all items
        foreach ($item in $list.Items) {
            $itemCount++
            $itemId = $item.ID
            
            # Clean the title for use in filename
            $title = "NoTitle"
            if ($item["Title"] -and $item["Title"].ToString().Trim() -ne "") {
                $title = $item["Title"].ToString().Trim() -replace '[\\/:*?"<>|]', '_'
                # Limit title length for filename
                if ($title.Length -gt 50) {
                    $title = $title.Substring(0, 47) + "..."
                }
            }
            
            # Construct potential Nintex form URLs
            $webUrl = $web.Url
            $possibleUrls = @(
                "$webUrl/Lists/$($list.RootFolder.Name)/Item/displayifs.aspx?ID=$itemId",
                "$webUrl/Lists/$($list.RootFolder.Name)/DispForm.aspx?ID=$itemId",
                "$webUrl/_layouts/15/listform.aspx?PageType=4&ListId={$($list.ID)}&ID=$itemId",
                "$webUrl/_layouts/listform.aspx?PageType=4&ListId={$($list.ID)}&ID=$itemId"
            )
            
            # Use the first URL pattern as default (adjust if needed)
            $formUrl = $possibleUrls[0]
            
            $itemData = [PSCustomObject]@{
                Id = $itemId
                Title = $title
                Url = $formUrl
                Created = $item["Created"]
                Modified = $item["Modified"]
                ListName = $list.Title
            }
            
            $formData += $itemData
            
            # Progress indicator for large lists
            if ($itemCount % 100 -eq 0) {
                Write-Host "Processed $itemCount items..." -ForegroundColor Gray
            }
        }
        
        Write-Host "Retrieved $($formData.Count) form items" -ForegroundColor Green
        
        # Dispose SharePoint objects
        $web.Dispose()
        $site.Dispose()
        
        return $formData
        
    }
    catch {
        Write-Error "Failed to get SharePoint list items: $($_.Exception.Message)"
        
        # Cleanup on error
        if ($web) { $web.Dispose() }
        if ($site) { $site.Dispose() }
        
        return @()
    }
}

# Function to test if a URL is accessible
function Test-FormUrl {
    param([string]$Url)
    
    try {
        $response = Invoke-WebRequest -Uri $Url -Method Head -UseDefaultCredentials -TimeoutSec 10
        return $response.StatusCode -eq 200
    }
    catch {
        return $false
    }
}

# Main execution
Write-Host "=== Nintex Forms PDF Export ===" -ForegroundColor Cyan
Write-Host "SharePoint Web: $WebUrl" -ForegroundColor White
Write-Host "List Name: $ListName" -ForegroundColor White
Write-Host "Output Path: $OutputPath" -ForegroundColor White
Write-Host "Export Method: $Method" -ForegroundColor White
Write-Host "Batch Size: $BatchSize" -ForegroundColor White

# Validate Chrome/wkhtmltopdf availability
switch ($Method.ToLower()) {
    "chrome" {
        if (!(Test-Path $ChromePath)) {
            Write-Error "Chrome not found at: $ChromePath"
            Write-Host "Please install Chrome or specify correct path with -ChromePath parameter"
            exit 1
        }
        Write-Host "Using Chrome at: $ChromePath" -ForegroundColor Green
    }
    "wkhtmltopdf" {
        if (!(Test-Path $wkhtmltopdfPath)) {
            Write-Error "wkhtmltopdf not found at: $wkhtmltopdfPath"
            Write-Host "Please install wkhtmltopdf or specify correct path with -wkhtmltopdfPath parameter"
            exit 1
        }
        Write-Host "Using wkhtmltopdf at: $wkhtmltopdfPath" -ForegroundColor Green
    }
    default {
        Write-Error "Invalid method: $Method. Use 'Chrome' or 'wkhtmltopdf'"
        exit 1
    }
}

# Create output directory
if (!(Test-Path -Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
    Write-Host "Created output directory: $OutputPath" -ForegroundColor Green
}

# Get all form items
Write-Host "`nRetrieving list items..." -ForegroundColor Yellow
$forms = Get-SharePointListItems -WebUrl $WebUrl -ListName $ListName

if ($forms.Count -eq 0) {
    Write-Host "No forms found. Exiting." -ForegroundColor Red
    exit 1
}

Write-Host "Found $($forms.Count) forms to export`n" -ForegroundColor Green

# Test first form URL to validate URL pattern
Write-Host "Testing first form URL..." -ForegroundColor Yellow
$testForm = $forms[0]
Write-Host "Test URL: $($testForm.Url)" -ForegroundColor Gray

if (Test-FormUrl -Url $testForm.Url) {
    Write-Host "✓ URL pattern appears correct" -ForegroundColor Green
} else {
    Write-Host "⚠ URL pattern may need adjustment" -ForegroundColor Yellow
    Write-Host "If exports fail, you may need to modify the URL pattern in the script" -ForegroundColor Yellow
}

# Process forms in batches
$successCount = 0
$failureCount = 0
$processedCount = 0

for ($i = 0; $i -lt $forms.Count; $i += $BatchSize) {
    $batch = $forms[$i..([Math]::Min($i + $BatchSize - 1, $forms.Count - 1))]
    $batchNumber = [Math]::Floor($i / $BatchSize) + 1
    $totalBatches = [Math]::Ceiling($forms.Count / $BatchSize)
    
    Write-Host "`nProcessing batch $batchNumber of $totalBatches ($($batch.Count) items)..." -ForegroundColor Cyan
    
    foreach ($form in $batch) {
        $processedCount++
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $fileName = "NintexForm_ID$($form.Id)_$($form.Title)_$timestamp.pdf"
        $outputFile = Join-Path -Path $OutputPath -ChildPath $fileName
        
        Write-Host "[$processedCount/$($forms.Count)] Processing ID $($form.Id): $($form.Title)" -ForegroundColor White
        
        $success = $false
        
        switch ($Method.ToLower()) {
            "chrome" {
                $success = Export-WithChrome -Url $form.Url -OutputFile $outputFile -ChromePath $ChromePath
            }
            "wkhtmltopdf" {
                $success = Export-WithWkhtmltopdf -Url $form.Url -OutputFile $outputFile -WkhtmltopdfPath $wkhtmltopdfPath
            }
        }
        
        if ($success) {
            $successCount++
            $fileSize = [Math]::Round((Get-Item $outputFile).Length / 1KB, 1)
            Write-Host "  ✓ Success ($fileSize KB)" -ForegroundColor Green
        } else {
            $failureCount++
            Write-Host "  ✗ Failed" -ForegroundColor Red
            
            # Log failed URL for troubleshooting
            "$($form.Url)" | Out-File -FilePath "$OutputPath\FailedURLs.txt" -Append
        }
        
        # Overall progress
        $percentComplete = [Math]::Round(($processedCount / $forms.Count) * 100, 1)
        Write-Progress -Activity "Exporting Nintex Forms" -Status "$processedCount of $($forms.Count) processed" -PercentComplete $percentComplete
    }
    
    # Small delay between batches to prevent overwhelming the system
    if ($i + $BatchSize -lt $forms.Count) {
        Write-Host "Pausing between batches..." -ForegroundColor Gray
        Start-Sleep -Seconds 2
    }
}

# Final summary
Write-Progress -Activity "Exporting Nintex Forms" -Completed

Write-Host "`n=== EXPORT SUMMARY ===" -ForegroundColor Yellow
Write-Host "Total forms processed: $($forms.Count)" -ForegroundColor White
Write-Host "Successful exports: $successCount" -ForegroundColor Green
Write-Host "Failed exports: $failureCount" -ForegroundColor Red
Write-Host "Success rate: $([Math]::Round(($successCount / $forms.Count) * 100, 1))%" -ForegroundColor White
Write-Host "Output directory: $OutputPath" -ForegroundColor Cyan

# Create detailed log
$logData = @{
    ExportDate = Get-Date
    WebUrl = $WebUrl
    ListName = $ListName
    ExportMethod = $Method
    TotalForms = $forms.Count
    SuccessfulExports = $successCount
    FailedExports = $failureCount
    OutputPath = $OutputPath
    BatchSize = $BatchSize
}

$logPath = Join-Path -Path $OutputPath -ChildPath "ExportLog_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
$logData | ConvertTo-Json -Depth 2 | Out-File -FilePath $logPath -Encoding UTF8

Write-Host "`nDetailed log saved: $logPath" -ForegroundColor Cyan

if ($failureCount -gt 0) {
    Write-Host "Failed URLs logged to: $OutputPath\FailedURLs.txt" -ForegroundColor Yellow
}

Write-Host "`nExport completed!" -ForegroundColor Green
