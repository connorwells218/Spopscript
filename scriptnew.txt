# Robust Nintex Forms PDF Export with Enhanced Error Handling
# This version handles the Get-SharePointListItems issues seen in your output

param(
    [Parameter(Mandatory=$true)]
    [string]$WebUrl,
    
    [Parameter(Mandatory=$true)]
    [string]$ListName,
    
    [Parameter(Mandatory=$true)]
    [string]$OutputPath,
    
    [Parameter(Mandatory=$false)]
    [string]$Method = "Chrome",
    
    [Parameter(Mandatory=$false)]
    [string]$ChromePath = "C:\Program Files\Google\Chrome\Application\chrome.exe",
    
    [Parameter(Mandatory=$false)]
    [int]$BatchSize = 50
)

# Load SharePoint PowerShell Snap-in
Write-Host "Loading SharePoint PowerShell..." -ForegroundColor Yellow
try {
    Add-PSSnapin Microsoft.SharePoint.PowerShell -ErrorAction Stop
    Write-Host "SharePoint PowerShell loaded successfully" -ForegroundColor Green
}
catch {
    Write-Error "Failed to load SharePoint PowerShell. Ensure you're running on a SharePoint server."
    exit 1
}

# Function to export using Chrome headless
function Export-WithChrome {
    param(
        [string]$Url,
        [string]$OutputFile,
        [string]$ChromePath
    )
    
    $arguments = @(
        "--headless",
        "--disable-gpu",
        "--no-sandbox",
        "--disable-dev-shm-usage",
        "--disable-web-security",
        "--disable-features=VizDisplayCompositor",
        "--virtual-time-budget=15000",
        "--run-all-compositor-stages-before-draw",
        "--print-to-pdf=`"$OutputFile`"",
        "--print-to-pdf-no-header",
        "`"$Url`""
    )
    
    try {
        $process = Start-Process -FilePath $ChromePath -ArgumentList $arguments -Wait -NoNewWindow -PassThru
        Start-Sleep -Seconds 2
        
        if (Test-Path $OutputFile -and (Get-Item $OutputFile).Length -gt 1KB) {
            return $true
        } else {
            return $false
        }
    }
    catch {
        Write-Warning "Chrome export failed: $($_.Exception.Message)"
        return $false
    }
}

# Enhanced function to get SharePoint list items with better error handling
function Get-SharePointListItemsRobust {
    param(
        [string]$WebUrl,
        [string]$ListName
    )
    
    Write-Host "Connecting to SharePoint site: $WebUrl" -ForegroundColor Yellow
    
    $web = $null
    $site = $null
    
    try {
        # Method 1: Try to get web directly
        Write-Host "Attempting direct web connection..." -ForegroundColor Gray
        $web = Get-SPWeb $WebUrl -ErrorAction SilentlyContinue
        
        if ($web) {
            Write-Host "✓ Connected directly to web: $($web.Title)" -ForegroundColor Green
        } else {
            # Method 2: Try to find via site collection
            Write-Host "Direct connection failed, trying site collection approach..." -ForegroundColor Yellow
            
            # Get all site collections and find the right one
            $allSites = Get-SPSite -Limit All
            
            foreach ($testSite in $allSites) {
                try {
                    foreach ($testWeb in $testSite.AllWebs) {
                        if ($testWeb.Url -eq $WebUrl) {
                            $web = $testWeb
                            $site = $testSite
                            Write-Host "✓ Found web via site collection search: $($web.Title)" -ForegroundColor Green
                            break
                        }
                    }
                    if ($web) { break }
                } catch {
                    continue
                }
            }
        }
        
        if (!$web) {
            throw "Could not find web with URL: $WebUrl"
        }
        
        # Get the list with multiple approaches
        Write-Host "Looking for list: $ListName" -ForegroundColor Gray
        
        $list = $null
        
        # Try exact title match first
        try {
            $list = $web.Lists[$ListName]
        } catch {}
        
        # Try TryGetList method
        if (!$list) {
            try {
                $list = $web.Lists.TryGetList($ListName)
            } catch {}
        }
        
        # Try searching by title
        if (!$list) {
            try {
                $list = $web.Lists | Where-Object { $_.Title -eq $ListName }
            } catch {}
        }
        
        # Try partial match
        if (!$list) {
            try {
                $list = $web.Lists | Where-Object { $_.Title -like "*$ListName*" }
            } catch {}
        }
        
        if (!$list) {
            Write-Host "Available lists in this web:" -ForegroundColor Yellow
            foreach ($availableList in $web.Lists) {
                Write-Host "  - $($availableList.Title) ($($availableList.ItemCount) items)" -ForegroundColor Gray
            }
            throw "List '$ListName' not found in web '$($web.Title)'"
        }
        
        Write-Host "✓ Found list: $($list.Title) with $($list.ItemCount) items" -ForegroundColor Green
        
        if ($list.ItemCount -eq 0) {
            Write-Warning "List contains no items"
            return @()
        }
        
        # Get list items with error handling
        $formData = @()
        $itemCount = 0
        
        try {
            # Use SPQuery for better performance with large lists
            $query = New-Object Microsoft.SharePoint.SPQuery
            $query.ViewAttributes = "Scope='Recursive'"
            $query.RowLimit = 2000
            
            do {
                $items = $list.GetItems($query)
                
                foreach ($item in $items) {
                    $itemCount++
                    $itemId = $item.ID
                    
                    # Clean the title for filename
                    $title = "NoTitle"
                    if ($item["Title"] -and $item["Title"].ToString().Trim() -ne "") {
                        $title = $item["Title"].ToString().Trim() -replace '[\\/:*?"<>|]', '_'
                        if ($title.Length -gt 50) {
                            $title = $title.Substring(0, 47) + "..."
                        }
                    } else {
                        $title = "Item$itemId"
                    }
                    
                    # Construct Nintex form URLs with multiple patterns
                    $webUrl = $web.Url
                    $listUrl = $list.RootFolder.ServerRelativeUrl
                    
                    $possibleUrls = @(
                        "$webUrl/Lists/$($list.RootFolder.Name)/Item/displayifs.aspx?ID=$itemId",
                        "$webUrl$listUrl/Item/displayifs.aspx?ID=$itemId",
                        "$webUrl/Lists/$($list.RootFolder.Name)/DispForm.aspx?ID=$itemId",
                        "$webUrl$listUrl/DispForm.aspx?ID=$itemId",
                        "$webUrl/_layouts/15/listform.aspx?PageType=4&ListId={$($list.ID)}&ID=$itemId",
                        "$webUrl/_layouts/listform.aspx?PageType=4&ListId={$($list.ID)}&ID=$itemId"
                    )
                    
                    $itemData = [PSCustomObject]@{
                        Id = $itemId
                        Title = $title
                        PrimaryUrl = $possibleUrls[0]
                        AlternativeUrls = $possibleUrls[1..5]
                        Created = $item["Created"]
                        Modified = $item["Modified"]
                        ListName = $list.Title
                    }
                    
                    $formData += $itemData
                    
                    if ($itemCount % 100 -eq 0) {
                        Write-Host "  Processed $itemCount items..." -ForegroundColor Gray
                    }
                }
                
                $query.ListItemCollectionPosition = $items.ListItemCollectionPosition
                
            } while ($query.ListItemCollectionPosition -ne $null)
            
        } catch {
            Write-Error "Error retrieving list items: $($_.Exception.Message)"
            return @()
        }
        
        Write-Host "✓ Retrieved $($formData.Count) form items" -ForegroundColor Green
        
        return $formData
        
    } catch {
        Write-Error "Failed to get SharePoint list items: $($_.Exception.Message)"
        Write-Host "Stack trace:" -ForegroundColor Red
        Write-Host $_.ScriptStackTrace -ForegroundColor Red
        return @()
    } finally {
        # Clean up objects but don't dispose if we're returning them
        if ($web -and !$site) {
            # Only dispose if we got the web directly, not via site collection
            try { $web.Dispose() } catch {}
        }
    }
}

# Function to test form URL accessibility
function Test-FormUrlAccessible {
    param([string]$Url, [int]$TimeoutSeconds = 10)
    
    try {
        $request = [System.Net.WebRequest]::Create($Url)
        $request.Method = "HEAD"
        $request.Timeout = $TimeoutSeconds * 1000
        $request.UseDefaultCredentials = $true
        
        $response = $request.GetResponse()
        $statusCode = [int]$response.StatusCode
        $response.Close()
        
        return $statusCode -eq 200
    } catch {
        return $false
    }
}

# Main execution
Write-Host "=== Robust Nintex Forms PDF Export ===" -ForegroundColor Cyan
Write-Host "SharePoint Web: $WebUrl" -ForegroundColor White
Write-Host "List Name: $ListName" -ForegroundColor White
Write-Host "Output Path: $OutputPath" -ForegroundColor White
Write-Host "Export Method: $Method" -ForegroundColor White

# Validate Chrome
if (!(Test-Path $ChromePath)) {
    Write-Error "Chrome not found at: $ChromePath"
    Write-Host "Please install Chrome or specify correct path with -ChromePath parameter"
    exit 1
}
Write-Host "✓ Chrome found at: $ChromePath" -ForegroundColor Green

# Create output directory
if (!(Test-Path -Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
    Write-Host "✓ Created output directory: $OutputPath" -ForegroundColor Green
}

# Get all form items using robust method
Write-Host "`nRetrieving list items..." -ForegroundColor Yellow
$forms = Get-SharePointListItemsRobust -WebUrl $WebUrl -ListName $ListName

if ($forms.Count -eq 0) {
    Write-Host "No forms found. Exiting." -ForegroundColor Red
    exit 1
}

Write-Host "Found $($forms.Count) forms to export`n" -ForegroundColor Green

# Test first few form URLs to find the right pattern
Write-Host "Testing form URL patterns..." -ForegroundColor Yellow
$workingUrlPattern = $null
$testForms = $forms | Select-Object -First 3

foreach ($testForm in $testForms) {
    Write-Host "Testing Item ID $($testForm.Id):" -ForegroundColor Gray
    
    # Test primary URL
    Write-Host "  Testing: $($testForm.PrimaryUrl)" -ForegroundColor Gray
    if (Test-FormUrlAccessible -Url $testForm.PrimaryUrl) {
        Write-Host "  ✓ Primary URL works!" -ForegroundColor Green
        $workingUrlPattern = "Primary"
        break
    }
    
    # Test alternative URLs
    for ($i = 0; $i -lt $testForm.AlternativeUrls.Count; $i++) {
        $altUrl = $testForm.AlternativeUrls[$i]
        Write-Host "  Testing: $altUrl" -ForegroundColor Gray
        if (Test-FormUrlAccessible -Url $altUrl) {
            Write-Host "  ✓ Alternative URL #$($i+1) works!" -ForegroundColor Green
            $workingUrlPattern = "Alternative$($i+1)"
            break
        }
    }
    
    if ($workingUrlPattern) { break }
}

if (!$workingUrlPattern) {
    Write-Warning "Could not find accessible form URLs. Proceeding with primary URL pattern..."
    $workingUrlPattern = "Primary"
}

# Process forms
$successCount = 0
$failureCount = 0

foreach ($form in $forms) {
    $processedCount = $successCount + $failureCount + 1
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $fileName = "NintexForm_ID$($form.Id)_$($form.Title)_$timestamp.pdf"
    $outputFile = Join-Path -Path $OutputPath -ChildPath $fileName
    
    # Select URL based on working pattern
    $formUrl = switch ($workingUrlPattern) {
        "Primary" { $form.PrimaryUrl }
        "Alternative1" { $form.AlternativeUrls[0] }
        "Alternative2" { $form.AlternativeUrls[1] }
        "Alternative3" { $form.AlternativeUrls[2] }
        "Alternative4" { $form.AlternativeUrls[3] }
        "Alternative5" { $form.AlternativeUrls[4] }
        default { $form.PrimaryUrl }
    }
    
    Write-Host "[$processedCount/$($forms.Count)] Processing ID $($form.Id): $($form.Title)" -ForegroundColor White
    Write-Host "  URL: $formUrl" -ForegroundColor Gray
    
    $success = Export-WithChrome -Url $formUrl -OutputFile $outputFile -ChromePath $ChromePath
    
    if ($success) {
        $successCount++
        $fileSize = [Math]::Round((Get-Item $outputFile).Length / 1KB, 1)
        Write-Host "  ✓ Success ($fileSize KB)" -ForegroundColor Green
    } else {
        $failureCount++
        Write-Host "  ✗ Failed" -ForegroundColor Red
        "$formUrl" | Out-File -FilePath "$OutputPath\FailedURLs.txt" -Append
    }
    
    $percentComplete = [Math]::Round(($processedCount / $forms.Count) * 100, 1)
    Write-Progress -Activity "Exporting Nintex Forms" -Status "$processedCount of $($forms.Count) processed" -PercentComplete $percentComplete
}

# Final summary
Write-Progress -Activity "Exporting Nintex Forms" -Completed

Write-Host "`n=== EXPORT SUMMARY ===" -ForegroundColor Yellow
Write-Host "Total forms processed: $($forms.Count)" -ForegroundColor White
Write-Host "Successful exports: $successCount" -ForegroundColor Green
Write-Host "Failed exports: $failureCount" -ForegroundColor Red
Write-Host "Success rate: $([Math]::Round(($successCount / $forms.Count) * 100, 1))%" -ForegroundColor White
Write-Host "Output directory: $OutputPath" -ForegroundColor Cyan

Write-Host "`nExport completed!" -ForegroundColor Green
